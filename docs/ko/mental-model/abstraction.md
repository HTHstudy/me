---
layout: default
title: 추상화
parent: Mental Model
grand_parent: 한국어
nav_order: 1
permalink: /docs/ko/mental-model/abstraction
---

# 추상화

## 들어가며 — 왜 우리는 추상화를 오해하는가

추상화는 개발자에게 거의 항상  
“좋은 것”으로 받아들여진다.

중복을 줄이고,  
코드를 정리하고,  
구조를 깔끔하게 만든다.

그래서 우리는 종종 이렇게 말한다.

> “여기 중복이 있으니까 추상화하자.”

하지만 실무에서 추상화가 문제를 일으키는 순간들을 돌아보면,  
문제의 원인은 대개 구현의 완성도가 아니라  
**추상화를 대하는 전제 자체**에 있었다.

추상화가 실패했을 때 우리는 종종 이렇게 반응한다.

- 추상화가 덜 됐다
- 인터페이스가 잘못됐다
- 설계를 다시 하면 된다

하지만 그보다 먼저 던져야 할 질문은 이것이다.

> “이건 정말 추상화해야 할 대상이었을까?”

이 문서는  
추상화를 기술이나 패턴의 문제가 아니라,  
**어떤 선택을 했는가의 문제**로 다루기 위해 쓰였다.

중복을 없애는 방법이 아니라,  
**무엇을 고정하고 무엇을 열어두었는지**를  
다시 생각해보기 위한 기록이다.

---

## 이 문서에서 말하는 추상화란?

이 문서에서 말하는 추상화는  
코드를 짧게 만들거나 중복을 제거하는 기술을 의미하지 않는다.

추상화란  
여러 구현 위에 하나의 이름과 인터페이스를 올리는 행위이며,  
그 순간 우리는 하나의 강한 가정을 하게 된다.

> **“이 책임은 앞으로도 변하지 않을 것이다.”**

이 가정이  
이 문서에서 말하는 추상화의 핵심이다.

추상화는  
무언가를 숨기는 행위처럼 보이지만,  
실제로는 **무언가를 고정하는 선택**에 가깝다.

인터페이스가 생긴다는 것은  
구현을 자유롭게 바꿀 수 있다는 의미처럼 들리지만,  
그 이면에서는 다음과 같은 선언이 함께 이루어진다.

- 이 책임은 하나다
- 이 책임은 분리되지 않을 것이다
- 이 책임은 같은 방식으로 사용될 것이다

즉, 추상화는  
“지금은 같다”는 관찰이 아니라,  
**“앞으로도 같을 것이다”라는 선언**이다.

그래서 이 문서에서는  
추상화를 다음과 같이 정의한다.

> 추상화는 공통점을 뽑아내는 행위가 아니라,  
> **변하지 않을 것이라고 가정한 책임을 하나로 묶는 행위**다.

이 가정이 맞을 때,  
추상화는 구조를 단순하게 만든다.

하지만 이 가정이 틀리는 순간,  
추상화는 중복을 줄이는 도구가 아니라  
<U>변화를 막는 장벽이 된다.</U>

---

## 중복 제거와 추상화는 같은 말이 아니다

추상화에 대해 이야기할 때  
가장 흔하게 등장하는 근거는 중복이다.

> “이 코드들 거의 똑같은데,  
> 하나로 추상화하면 되지 않을까?”

하지만 여기에는 중요한 전제가 하나 빠져 있다.

중복은  
**지금의 상태**를 설명할 뿐,  
**미래의 변화를 보장하지 않는다.**

코드가 지금 비슷해 보인다는 사실과  
그 책임이 앞으로도 같을 것이라는 가정은  
전혀 다른 이야기다.

중복 제거는  
“지금 같다”는 관찰에 대한 반응이고,  
추상화는  
“앞으로도 같을 것이다”라는 선언이다.

이 둘을 같은 말처럼 사용하는 순간,  
우리는 무의식적으로  
미래의 변화를 하나의 방향으로 고정해 버린다.

그래서 이른 추상화가 위험하다고 말할 때,  
그 위험은 구현의 미숙함에 있지 않다.

위험한 것은  
아직 충분히 드러나지 않은 변화를  
하나의 책임으로 묶어 버리는 선택이다.

중복은 나중에도 제거할 수 있다.  
하지만 잘못된 추상화는  
되돌리기 훨씬 어렵다.

이 차이를 인식하지 못하면,  
중복을 줄이려는 선의가  
변경을 가로막는 구조로 바뀌게 된다.

---

## 추상화는 언제 위험해지는가

추상화가 위험한 이유는  
우리가 실수해서가 아니다.

추상화는 본질적으로  
**미래를 고정하는 선택**이기 때문에 위험하다.

앞에서 말했듯, 추상화는 이렇게 선언한다.

> “이 책임은 변하지 않을 것이다.”

문제는 이 선언이 틀릴 수 있다는 사실이 아니라,  
한 번 선언된 이 가정이  
**생각보다 훨씬 비싸게** 돌아온다는 데 있다.

잘못된 추상화의 대가는  
“코드가 예쁘지 않다” 수준에서 끝나지 않는다.  
변경의 위치를 흐리고, 책임을 섞고,  
되돌리는 비용을 폭발시킨다.

---

### 변화가 아직 드러나지 않았을 때

가장 위험한 순간은  
변화가 충분히 관찰되기 전에  
인터페이스를 먼저 고정해 버릴 때다.

코드가 지금 비슷해 보인다는 이유로  
그 책임을 하나로 묶는 순간,  
우리는 무의식적으로 이렇게 말하게 된다.

> “이 차이들은 앞으로도 중요하지 않을 것이다.”

하지만 실무에서 차이는 자주  
“처음부터 없던 것”이 아니라  
“**아직 드러나지 않았던 것**”일 뿐이다.

이 시점의 추상화는  
미래를 예측하는 것이 아니라,  
**미래를 한 방향으로 강제**하는 선택이 된다.

---

### 변경이 독립적으로 일어날 가능성이 있을 때

추상화는 보통 이런 전제를 갖는다.

> “이 둘은 항상 함께 변할 것이다.”

하지만 실제로는  
지금은 같아 보이는 책임들이  
서로 다른 이유로, 다른 속도로 변화한다.

이때 하나의 추상화 아래에 묶인 책임들은  
서로의 변경을 방해하기 시작한다.

- 한쪽 변경이 다른 쪽에 영향을 주고
- 영향 범위를 예측하기 어려워지며
- 결국 “건드리기 무서운 코드”가 된다

여기서 중요한 건  
코드가 복잡해졌다는 사실이 아니라,  
**변경의 이유와 수정 위치가 더 이상 자연스럽게 연결되지 않는다는 점**이다.

---

### 도메인이 충분히 이해되지 않았을 때

추상화는  
문제를 단순화하는 행위처럼 보이지만,  
실제로는 문제를 **정확히 이해했을 때만** 가능한 선택이다.

도메인에 대한 이해가 부족한 상태에서의 추상화는  
공통점을 뽑아내는 것이 아니라,  
차이를 덮어두는 것에 가깝다.

이 경우 인터페이스는  
명확한 의도를 담기보다  
모호한 타협의 결과물이 된다.

그리고 그 모호함은  
시간이 지날수록  
구조 전체로 퍼져 나간다.

---

### 이른 추상화가 위험하다는 말의 진짜 의미

그래서 “이른 추상화는 위험하다”는 말은  
“아무것도 하지 말라”는 조언이 아니다.

그 말의 진짜 의미는 이것에 가깝다.

> 변화가 충분히 드러나기 전까지는,  
> **책임을 하나로 고정하지 말라.**

추상화는  
문제를 미리 해결하는 기술이 아니라,  
**문제가 충분히 드러난 뒤에 내리는 선택**이다.

---

## 좋은 추상화가 되기 위한 조건

앞에서 살펴봤듯,  
추상화는 본질적으로 미래를 고정하는 선택이다.

따라서 중요한 질문은  
“추상화를 할 수 있는가”가 아니라,  
**“지금 이 추상화가 감당 가능한 가정을 하고 있는가”**다.

이 섹션에서는  
추상화를 결정하기 전에 반드시 점검해야 할 조건들을 정리한다.

---

### 추상화를 결정하기 전에 던져야 할 질문들

아래 질문들은  
추상화를 시도하기 전에 스스로에게 던져야 하는 질문들이다.

| 스스로에게 던질 질문                                      | Yes라면          | No라면          |
| --------------------------------------------------------- | ---------------- | --------------- |
| 이 코드들은 **같은 역할을 한다고 말할 수 있는가?**        | 추상화 고려 가능 | 경계 분리 필요  |
| 이 코드들은 **항상 함께 수정될 것 같은가?**               | 추상화 가능      | 독립적으로 유지 |
| 사용하는 **데이터와 규칙이 실제로 같은가?**               | 추상화 가능      | 분리 신호       |
| 이 추상화가 **무엇을 하는지 한 문장으로 말할 수 있는가?** | 안정 가능성 ↑    | 아직 이르다     |
| 나중에 이 추상화를 **되돌리기 어렵지 않은가?**            | 실험 가능        | 비용 높음       |
| 지금 추상화하지 않으면 **당장 문제가 생기는가?**          | 고려 가치 있음   | 미뤄도 됨       |

이 표에서  
“No”에 해당하는 항목이 늘어날수록,  
이 추상화는 위험해진다.

특히

- 의미가 하나로 설명되지 않거나
- 변경이 독립적으로 일어날 가능성이 있다면

그 차이는  
아직 하나의 책임으로 묶일 준비가 되지 않은 상태다.

---

### 좋은 추상화의 공통적인 특징

위 조건을 만족하는 추상화들은  
다음과 같은 특징을 가진다.

- 인터페이스가 단순하다
- 역할을 한 문장으로 설명할 수 있다
- 구현보다 **의도가 먼저 보인다**
- 변경이 발생해도 영향 범위를 예측할 수 있다

이런 추상화는  
중복을 줄이기 위한 선택이 아니라,  
**변화를 다루기 위한 구조**로 작동한다.

---

### 기준의 목적

이 기준의 목적은  
추상화를 더 적극적으로 하도록 유도하는 것이 아니다.

오히려  
**추상화를 늦추거나, 하지 않기로 결정할 수 있게 만드는 기준**에 가깝다.

추상화를 하지 않는 선택 역시  
하나의 명확한 설계 결정이다.

이 기준을 의식적으로 적용하기 시작하면,  
추상화는 더 이상  
감각이나 경험에 의존한 선택이 아니라,  
설명 가능한 판단이 된다.

---

## 추상화와 관심사 분리의 관계

추상화와 관심사 분리는  
함께 자주 언급되지만, 서로를 대체하는 개념은 아니다.

- 추상화는 **복잡도를 다루기 위해 공통점을 묶는 선택**이고
- 관심사 분리는 **그 선택이 경계를 침범하지 않도록 지키는 원칙**이다

하지만 두 개념은  
**같은 실패 지점을 공유한다.**  
서로를 제약하고 검증하는 관계에 가깝다.

---

### 추상화는 경계를 흐릴 수 있다

추상화는 공통점을 묶는 과정에서  
의도치 않게 서로 다른 책임까지 한곳에 모을 수 있다.

특히 인터페이스가 다음 역할까지 떠안기 시작하면 위험해진다.

- 표현(UI)뿐 아니라 데이터 소스까지
- 공통 구조뿐 아니라 비즈니스 규칙까지
- 설정 값과 분기 조건이 늘면서  
  서로 다른 요구를 동시에 만족시키려는 순간

이때 추상화는  
단순화가 아니라 **결합**으로 작동할 수 있다.

---

### 관심사 분리는 “분리”가 아니라 “경계 유지”다

관심사 분리는  
무조건 쪼개라는 규칙이 아니다.

관심사 분리가 말하는 핵심은  
“무엇을 어디까지 함께 묶을 수 있는가”에 대한 **경계 판단**이다.

그래서 관심사 분리는  
추상화를 부정하기보다  
추상화의 범위를 조정하는 방향으로 작동한다.

- 공통화가 필요한 부분만 남기고
- 도메인별 차이는 각자의 자리로 돌려보내고
- 변경이 독립적인 부분을 억지로 한곳에 두지 않게 만든다

---

### 다시 정리하면

- 추상화는 **무엇을 하나로 묶을 것인가**에 대한 선택이고
- 관심사 분리는 **그 선택이 여전히 유효한지 확인하는 기준**이다

관심사 분리가 무너졌다면,  
대개 그 원인은  
관심사를 나누지 않았기 때문이 아니라,  
**처음에 너무 많은 것을 하나로 묶었기 때문**이다.

이 관점을 가지면  
관심사 분리는  
추상화를 더 잘하기 위한 기술이 아니라,  
**추상화를 다시 의심해보기 위한 신호**가 된다.

---

## 추상화는 언제까지 유효한가

지금까지의 내용을 따라오면  
이런 질문이 자연스럽게 남는다.

> “그럼 추상화는 언제까지 유효한가?”  
> “어디까지 묶는 게 맞고, 어디서 멈춰야 하는가?”

이 질문에 대한 답은  
추상화의 형태나 패턴이 아니라,  
**그 추상화가 무엇을 대표하고 있는지**에 달려 있다.

---

### 추상화가 유지될 수 있는 조건

추상화는 다음 조건을 만족하는 동안에는  
안정적으로 유지될 수 있다.

- 하나의 책임을 대표하고 있고
- 변경의 이유가 명확하며
- 변경이 발생할 때 영향 범위를 예측할 수 있을 때

이 상태에서의 추상화는  
복잡도를 줄이기 위한 구조로 기능한다.

문제는 이 조건들이  
조용히 깨지기 시작할 때다.

---

### 추상화가 흔들리기 시작하는 신호

다음과 같은 신호가 보이기 시작한다면,  
그 추상화는 이미  
유효 범위의 끝자락에 와 있을 가능성이 크다.

- 추상화된 인터페이스에 예외가 늘어난다
- 특정 경우에만 의미 있는 옵션이 생긴다
- 조건 분기가 계속 추가된다
- “이 경우는 조금 다르다”는 설명이 반복된다

이때 추상화는  
하나의 책임을 대표하지 못하고,  
서로 다른 요구를 동시에 수용하려는 구조로 변한다.

---

### 도구로서의 추상화 — parameter의 역할

이 지점에서 자주 등장하는 선택지는  
하나의 추상화에  
parameter를 추가하는 방식이다.

parameter는 본래  
같은 책임을 가진 대상의  
**표현이나 설정 차이**를 다루기 위한 수단이다.

하지만 parameter가  
행동, 규칙, 흐름의 차이까지 흡수하기 시작하면  
그 순간 추상화는  
책임을 표현하는 수단이 아니라  
**책임을 감추는 수단**이 된다.

겉으로 보면  
하나의 추상화와 하나의 인터페이스만 존재한다.

하지만 실제로는  
서로 다른 의미들이  
같은 이름과 같은 진입점 아래에 놓이게 된다.

이때 문제는  
parameter가 늘어났다는 사실이 아니라,  
**하나의 추상화가 감당해야 할 책임이  
이미 하나를 넘어섰다는 점**이다.

---

### 추상화의 끝은 실패가 아니다

중요한 점은  
추상화가 더 이상 유효하지 않다는 사실이  
실패를 의미하지는 않는다는 것이다.

오히려 그것은  
도메인이 분화되었고,  
변화가 충분히 드러났다는 신호다.

이 시점에서 필요한 선택은  
추상화를 억지로 유지하는 것이 아니라,  
**그 책임을 다시 드러내는 것**이다.

추상화는  
영원히 유지되어야 할 구조가 아니라,  
유효한 동안만 유지되는 선택이다.

---

## 정리하며 — 추상화를 다시 정의하면

이 문서에서 다룬 추상화는  
코드를 정리하는 기술도,  
중복을 제거하는 요령도 아니다.

추상화는  
여러 구현을 하나로 묶는 선택이며,  
그 선택에는 언제나 하나의 가정이 따라온다.

> “이 책임은 변하지 않을 것이다.”

이 가정이 맞을 때,  
추상화는 복잡도를 낮추고  
구조를 단순하게 만든다.

하지만 이 가정이 틀리는 순간,  
추상화는 문제를 숨기고  
변경을 어렵게 만드는 구조로 바뀐다.

그래서 이 문서에서 말하는 추상화는  
얼마나 많은 코드를 줄였는지가 아니라,  
**무엇을 고정했고, 무엇을 열어두었는가**로 평가된다.

- 어떤 책임을 하나로 묶었는가
- 어떤 차이를 중요하지 않다고 판단했는가
- 어떤 변화는 일어나지 않을 것이라고 가정했는가

이 질문들에 대한 답이  
추상화의 품질을 결정한다.

추상화는  
언제나 옳은 선택도,  
언제나 피해야 할 선택도 아니다.

그것은  
도메인에 대한 이해와  
미래 변화에 대한 가정을 바탕으로 내리는  
**비용이 따르는 결정**이다.

이 관점을 가지면,  
추상화는 더 이상  
습관적으로 적용하는 기술이 아니라,  
의식적으로 선택해야 할 설계 판단이 된다.
