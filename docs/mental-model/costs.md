---
layout: default
title: 비용
parent: Mental Model
nav_order: 5
permalink: /docs/mental-model/costs
---

# 비용: 무엇을 지불하고 있는가

## 들어가며 — 비용은 시간만이 아니다

개발을 하다 보면  
자연스럽게 이런 생각을 한다.

> "이 기능을 구현하는데 얼마나 걸릴까?"

시간은 명확하다.  
하지만 개발에서 지불하는 비용은 시간만이 아니다.

```tsx
// 빠르게 작성한 코드
export const UserList = () => {
  const [users, setUsers] = useState([]);
  
  useEffect(() => {
    fetch('/api/users')
      .then(res => res.json())
      .then(data => {
        // 중복 제거 로직이 여기 있음
        // 정렬 로직도 여기 있음
        // 나중에 수정해야 할 부분
        setUsers(data);
      });
  }, []);
  
  return (
    <div>
      {users.map(user => (
        <div key={user.id}>
          <h3>{user.name}</h3>
          <p>{user.email}</p>
        </div>
      ))}
    </div>
  );
};
```

이 코드는 빠르게 작성되었다.  
하지만 나중에 누군가 이 코드를 읽을 때:

- 왜 이 로직이 여기 있는가?
- 이 로직을 다른 곳에서도 써야 한다면?
- 수정할 때 어디를 건드려야 하는가?

**시간은 절약했지만, 다른 비용을 지불하고 있다.**

이 문서는  
개발에서 지불하는 비용을  
인식하는 사고 렌즈를 제공하기 위해 쓰였다.

---

## 개발에서의 비용이란 무엇인가

개발에서의 비용은  
**코드를 작성하고 유지하기 위해 지불하는 모든 것**이다.

시간만이 아니다.  
인지 부하, 유연성, 신뢰성, 확장성 등  
다양한 형태로 비용이 발생한다.

### 비용의 특징

비용은 보통:
- **지연된다**: 지금 절약한 비용이 나중에 더 크게 돌아온다
- **전파된다**: 한 곳의 비용이 다른 곳으로 퍼진다
- **누적된다**: 작은 비용들이 모여 큰 비용이 된다

이 세 가지 특징이  
비용을 이해하는 핵심이다.

---

## 비용의 종류

### 1. 시간 비용 (Time Cost)

가장 명확한 비용이다.  
**측정 가능한 시간**이 여기에 속한다.

#### 개발 시간
- 기능을 처음 구현하는데 걸리는 시간
- 버그를 수정하는데 걸리는 시간

#### 유지보수 시간
- 버그를 찾고 수정하는 시간
- 기능을 변경하거나 확장하는 시간
- 코드를 이해하는 시간

#### 배포 시간
- 코드를 빌드하고 배포하는데 걸리는 시간
- 번들 크기가 커지면 다운로드 시간이 늘어남

#### 테스트 시간
- 테스트 코드를 작성하는데 걸리는 시간
- 테스트를 실행하고 결과를 확인하는 시간

**시간 비용은 명확하지만, 유일한 비용은 아니다.**

---

### 2. 인지 부하 (Cognitive Load)

코드를 이해하고 작업하는데 필요한 **정신적 에너지**다.

#### 읽기 비용
- 코드의 의도를 파악하는데 필요한 노력
- 복잡한 로직을 추적하는데 필요한 노력

#### 추적 비용
- 상태가 어디서 변경되는지 찾는 비용
- 데이터가 어떻게 흐르는지 추적하는 비용
- 의존성이 어떻게 연결되어 있는지 파악하는 비용

#### 학습 비용
- 새로운 코드나 패턴을 이해하는데 필요한 비용
- 새로운 팀원이 코드베이스를 이해하는데 걸리는 시간
- 프로젝트의 구조와 패턴을 학습하는 시간

#### 온보딩 비용
- 새로운 팀원이 프로젝트에 기여할 수 있을 때까지의 시간
- 복잡한 커스텀 훅이나 패턴을 이해하는 시간

**인지 비용은 시간으로 직접 측정하기 어렵지만, 실질적인 비용이다.**

---

### 3. 변경 비용 (Change Cost)

코드를 수정하거나 개선하는데 필요한 비용이다.  
**미래의 수정이 얼마나 어려운가**를 나타낸다.

#### 리팩토링 비용
- 코드를 개선하기 위해 필요한 비용
- 코드를 수정할 때 다른 부분이 깨질 위험
- 테스트가 없어서 수정을 두려워하게 되는 비용

#### 기술 부채
- 빠른 구현을 위해 나중으로 미룬 작업들이 쌓인 것
- TODO 주석으로 남긴 작업
- 임시로 작성한 코드
- 나쁜 설계로 인한 복잡도 증가

#### 결합 비용
- 컴포넌트나 모듈이 강하게 결합되어 있어서
- 하나를 변경하면 여러 곳을 함께 변경해야 하는 비용

```tsx
// SuperPage를 여러 페이지가 공유
export const SuperPage = ({ title, children, width, ...props }) => {
  // 복잡한 공통 로직
  // PageA 로직
  // PageB 로직
  // PageC 로직
  return (
    <div className={`page page-${width}`}>
      <h1>{title}</h1>
      <div className="content">{children}</div>
    </div>
  );
};

// PageA, PageB, PageC가 모두 SuperPage를 사용
export const PageA = () => (
  <SuperPage title="페이지 A" width="wide">...</SuperPage>
);

export const PageB = () => (
  <SuperPage title="페이지 B" width="narrow">...</SuperPage>
);

export const PageC = () => (
  <SuperPage title="페이지 C" width="default">...</SuperPage>
);

// SuperPage의 width="wide" 스타일을 수정하면
// PageA도 함께 변경됨
// PageB만 다르게 하고 싶어도 SuperPage를 수정해야 함
// → 하나를 변경하면 여러 곳이 함께 영향받음
```

**변경 비용이 높으면 코드는 점점 경직된다.**

---

## 비용의 트레이드오프

개발에서의 비용은  
서로 트레이드오프 관계에 있다.

### 시간 vs 품질

빠른 구현을 선택하면  
나중에 더 많은 비용을 지불한다.

- 지금: 시간 절약
- 나중: 리팩토링 비용, 기술 부채, 인지 비용 증가

### 단순함 vs 유연성

유연성을 높이면  
인지 부하도 함께 높아진다.

- 유연한 구조: 여러 상황에 대응 가능
- 하지만: 코드를 이해하기 어려워짐

### 현재 vs 미래

현재를 위해 미래를 포기하면,  
미래에 더 많은 비용을 지불한다.

- 지금: 빠른 개발
- 나중: 변경 비용 증가, 기술 부채 누적

---

## 비용을 인식하지 못하면

비용을 인식하지 못하면:

### 1. 잘못된 최적화
- 보이지 않는 비용을 무시하고
- 보이는 비용(시간)만 최적화한다

### 2. 비용의 전파
- 한 곳에서 절약한 비용이
- 다른 곳에서 더 크게 발생한다

### 3. 누적된 비용
- 작은 비용들이 모여
- 큰 비용이 된다

---

## 비용은 어떻게 판단되는가

비용을 인식하는 것은  
"어떻게 관리할 것인가"가 아니라  
"어떻게 판단할 것인가"에서 시작한다.

### 판단 질문

선택을 할 때 스스로에게 물어보자:

- **이 선택으로 지금 줄어드는 비용은 무엇인가?**
- **이 비용은 언제 다시 등장할 것인가?**
- **이 비용을 지불하는 사람은 누구인가?**
- **이 비용은 지금 지불하는 게 나은가, 나중이 나은가?**

이 질문들은  
정답을 주지 않는다.

하지만  
**비용을 인식하게 만든다.**

---

## 기회 비용: 선택의 대가

모든 선택은  
다른 선택을 포기하는 것이다.

### 기능 선택
- 빠른 구현을 선택하면 코드 품질을 포기
- 완벽한 설계를 선택하면 빠른 배포를 포기

### 기술 선택
- 새로운 기술을 선택하면 안정성을 포기
- 검증된 기술을 선택하면 혁신을 포기

### 구조 선택
- 재사용을 선택하면 단순함을 포기
- 단순함을 선택하면 재사용을 포기

**기회 비용은 명시적으로 드러나지 않지만, 중요한 비용이다.**

---

## 정리하며 — 비용을 인식하면

개발에서의 비용은  
시간만이 아니다.

- **시간 비용**: 측정 가능한 시간
- **인지 비용**: 정신적 에너지
- **변경 비용**: 미래 수정의 어려움
- **기회 비용**: 선택으로 인한 포기

### 비용의 특징

비용은:
- **지연된다**: 지금 절약한 비용이 나중에 더 크게 돌아온다
- **전파된다**: 한 곳의 비용이 다른 곳으로 퍼진다
- **누적된다**: 작은 비용들이 모여 큰 비용이 된다

### 비용을 인식하는 것의 가치

비용을 인식하면:

- **의도적인 선택**을 할 수 있다
- **트레이드오프**를 이해할 수 있다
- **장기적인 관점**에서 생각할 수 있다

### 비용은 피할 수 없다

비용을 피할 수는 없다.  
하지만 **인식**할 수는 있다.

> 모든 코드는 비용을 지불한다.  
> 중요한 것은 어떤 비용을 지불할 것인지  
> 의도적으로 선택하는 것이다.

개발에서의 비용을 인식하는 것은  
더 나은 결정을 내리기 위한  
첫 번째 단계다.
